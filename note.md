# day01

## 01、脚手架创建项目

## 02、认识项目目录及各个目录的作用

## 03、vue 的 main.js 基本编码

## 04、eslint 错误级别禁用 lintOnSave: false,

文件夾名: vue.config.js

module.exports = {
lintOnSave: false,
}

## 05、jsconfig.json 配置别名@提示 import XXX from '@/'

```
{
"compilerOptions": {
"baseUrl": "./",
"paths": {
"@/_": ["src/_"]
}
},
"exclude": ["node_modules", "dist"]
}
```

配置完成跑起项目，没有报错各种都正常，证明项目准备没问题

跑起来运行报错 （warning 找不到 vue） 装的是 3.0 版本
我们用的是 2.6.11
需要重新安装 vue@2
又找不到 vue-template-compiler
安装 vue-template-compler

## 06、git 的基本操作和分支基本操作

### git 基本操作

- 先有本地代码
- 创建本地库
- 创建远程库
- 关联本地和远程
- 修改本地
- 修改远程

  先有远程代码
  直接克隆


    git分支扩展
    	分支创建和合并
    		本地创建分支   git checkout -b dev
    		本地推送新分支自动在远程库建立新分支  git push origin dev




    		合并分支之前如果是多人协作先拉取一下远程master，以防止别人已经做了更改
    		本地切换到master 然后再合并分支  git merge dev
    		合并之后再次推送到远程master




    	分支删除
    		项目开发完成可以删除分支
    		git push origin --delete dev  删除远程分支
    		git branch -d dev  删除本地分支

## 07、观察页面确定页面主体框架

所有的功能页面都是 上中下结构 上和下是不变化的，只有中间在变化

## 08、定义页面主体组件组装，切换路径可以组件跳转（非路由组件和路由组件）

1.  Header 和 Footer 是固定的所以是非路由组件
    Home Search Login Register 都是点击才会出现所以是路由组件并且是一级的（可能内部还有二级）
    非路由组件组装
    路由的注册使用
    路由可以分模块去编写

2.


    	1.路由組件和非路由組件的區別:
        		使用都是三大步: 1.定義 2.註冊 3.使用
        		定義都是一樣去定義的, 只是定義的文件夾不同

        2.註冊的時候分別:

            	非路由組件是註冊在要使用的組件當中
            	路由組件是要在路由配置當中註冊

        3.使用的時候區別:

            	非路由組件使用註冊的組件標籤
            	路由組件使用聲明式導航 (router-link / router-view), 和編程式導航來使用 (push / replace)

## 09、Header 和 Footer 非路由組件的使用

定義: 定義在 components
註冊: 註冊在 app
使用: 在 app 當中書寫組件標籤

## 10、Home Search Login Register 路由組件的使用

定義: 定義在 pages 中
註冊: 路由器的相關配置

    1.安裝路由 npm i vue-router -S
    2.引入並聲明使用路由插件
    3.向外暴露一個路由器對象
    4.在 main 當中把路由器註冊到 Vue 的配置對象上

註冊路由組件(配置路由)

    使用:
    	使用router-link和router-view
    	push和replace

## 11、把靜態頁面的東西複製到對應組件

    html        直接複製靜態頁面當中的html
    css(less)   npm i less less-loader


    			less-loader版本過高
    			npm install less-loader@7.3.0 --save-dev
    images		在對應的組件目錄下, 創建images, 把對應的圖片撈到
    			這文件夾下(注意路徑要對應好)

    複製完成後, 要把router-link用上, 把對應的a標籤修改過來, 按鈕點擊
    跳轉需要用到編程式導航
    重定向路由, 訪問根路徑, 默認訪問的就是home首頁

## 11、登录注册不需要 Footer,通过路由 meta 配置解决

从 route 当中可以获取到 path 判断可以解决但是麻烦

## 12、路由传参相关

![](C:\Users\Administrator\Desktop\路徑傳參過程.png)

    1)跳转路由的 2 种基本方式
    	声明式: <router-link to="">
    	编程式: this.$router.push()/replace()
    	編程式導航比聲明式導航更加靈活(內部可以加入自己的邏輯), 某些情況效率更好


    2)跳转路由携带参数的2种方式
    	params参数: 屬於路徑的一部份, 匹配的時候路由的path當中要照顧到這個參數, :xxx佔位
        query参数: 不屬於路徑的一部分, 匹配的時候, 路由的path不需要照顧到這個參數

    	無論是params還是query參數, 最後匹配成功都會解析到當前這個路由對象當中params和query屬性當中, 顯示路由的時候, 會被當這個路由對象, 傳遞給組件當中的this.$route, 所以
    	this.$route就可以獲取到之前傳遞的參數
    	this.$route.params.xxxx / this.$route.query.yyyyy


    5)面试问题3: 指定params参数时可不可以用path和params配置的组合?（对象写法）
    	不可以用path和params配置的组合,
    	只能用name和params配置的组合
    	query配置可以与path或name进行组合使用


    4)面试问题2: 如何指定params参数可传可不传?
    	path: '/search/:keyword?'



    6)面试问题4: 如果指定name与params配置, 但params中数据是一个"", 无法跳转，路径会出问题
    	前提是路由params参数要可传可不传
    		解决1: 不指定params
    	解决2: 指定params参数值为undefined


    7)面试问题5: 路由组件能不能传递props数据?
    		可以: 可以将query或且params参数映射/转换成props传递给路由组件对象
    	实现: props: (route)=>({keyword1:route.params.keyword, keyword2: route.query.keyword })

## day02

- 面试问题:
  描述: 编程式路由跳转到当前路由(参数不变), 多次执行会抛出 `NavigationDuplicated 的警告错误`
  声明式路由跳转内部已经处理
  原因：vue-router3.1.0 之后, 引入了 promise 的语法
  如果没有通过参数指定成功或者失败回调函数就返回一个 promise 且内部会判 断如果要跳转的路径和参数都没有变化,

  会抛出一个失败的 promise

      -解决:
      	1：在跳转时指定成功或失败的回调函数, 或者 catch 处理错误
      			這個解決方法不好, 因為不能一勞永逸, 後期如果用到了push /replace還是要寫
      	2: 修改 Vue 原型上的 push 和 replace 方法 (优秀)

## 13、先来搞 Home,Home 的子组件静态页面实现

费时费力 但是莫急莫慌
記得 reset css

- 拿三項
  1.html
  2.css
  3.images

Home 的静态页面就有了，接下来要去实现动态数据

1、TypeNav
2、图片路径

## 14、postman 测试后台 api 接口，保存请求信息以便后期使用（参考接口文档）

postman 的基本使用方法

跨域

    1. 是甚麼?
    	瀏覽器上的同源策略

    		特點:
    		1.跨域只存在於瀏覽器
    		2.不再瀏覽器發請求是不會存在跨域問題的
    		3.http請求分為兩大類:
    			1.普通請求 get(a標籤和地址欄輸入回車) 和post(form表單)
    				頁面會刷新
    			2.ajax請求 get post delete put 一般都是異步發送的, 頁面
    				不刷新

    2.在甚麼地方會出現跨域
    	瀏覽器給服務器發ajax請求會發生跨域, 因為跨域(同源策略)只存在瀏覽器
    	服務器給服務器發ajax請求不會

    3.甚麼條件會跨域
    	同源(協議 ip 端口)一致就不會跨域
    	反之就跨域 (任一不同)

    4. 解決跨域: 前後端都可以解決, 但後端解決比較容易

## 15、前后台交互模块 ajax 模块，对 axios 的二次封装

获取数据离不开 ajax，所以先把 ajax 工具搞定

    	配置基础路径和超时限制

    	添加进度条信息  nprogress

    	返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

    	统一处理请求错误, 具体请求也可以选择处理或不处理

## 16、所有接口的请求函数模块，我们定义一个 index.js 去写

以后请求什么数据直接导入去调函数就可以
先写请求三级分类列表数据
测试 ajax 请求是否能够拿到数据

## 17、测试 ajax 请求机解决跨域问题

返回 404 需要解决跨域
配置代理服务器解决跨域问题

## 18、可以拿到数据，但是我们得去管理我们的数据，使用 vuex

每个 vuex 模块都能包含 state mutations actions getters
多模块化 画图分析
总的 state 结构是什么
mapState 的写法分析 之前的 state 就是总的 state 现在 state 里面包含了子模块对象
state 结构要注意
state:{
home:{
},
user:{
}
}

## 19、获取到数据后显示三级分类列表

分析数据结构：在模板上展示数据 v-for

    鼠标悬停在链接上变色，需要修改一下公共样式
    悬停在分类上背景色需要变化，修改分类组件的样式
    三级分类列表宽度比较小，右边的缝隙比较大

### day03

## 20、事件控制 23 级的显示和隐藏

原来的是使用 css 去做的，咱们不用

1.  首先把原來的 hover 去掉, 改為一個類
2.  在 item 動態綁定 class, {item_on: 布爾值}, 布爾值為 true, 當前的這個 item 的類就生效
3.  移入哪一個 item, 就讓當前的 item 的類為 true
4.  設計一個數據, currentIndex = -1
5.  移入的時候, 讓 currentIndex = index

## 21、演示快速触发事件卡顿现象

## 22、函数的防抖和节流讲解

- 100 毫秒触发 100 次

  正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行(如果時間很短, 而回調函數內部 有計算, 那麼很可能出現瀏覽器卡頓)
  节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
  防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会，也就是说如果连续快速的触发 只会执行一次

- 總結

  節流: 正常情況多次執行變成少量執行
  防抖: 正常情況下的多次執行變為一次執行, 而且是最後一次

## 23、优化快速触发 typeNav 鼠标移入和移出事件，节流 lodash 的 throttle 节流操作

将移入事件的回调进行节流操作

## 24、按需引入 lodash 减少打包体积

引入的时候不要去引入整个 lodash
引入 lodash/throttle

## 25、解决使用 lodash 节流后，快速移出后，可能还会显示某个子项

默認 { 'trailing': true , leading: false }

'trailing': 是否在時間間隔之後執行函數
leading: 是否在時間間格之前執行函數

## 26、点击某个类别（无论几级）跳转到搜索页面

先用声明式导航替换原来的 a
需要把类别的 id 和类别的名字通过 query 参数传递

## 27、使用编程式路由导航优化声明式导航组件对象过多造成的卡顿

声明式导航本质上是组件对象，组件对象过多，会造成效率很慢，所以会很卡
​

## 28、利用事件委派提高处理事件的效率

每个项都添加事件，事件的回调函数很多，效率也不好
​ 在共同的祖先級元素添加事件监听
​ 问题：怎么知道点击的是不是 a 标签
​ 问题：假設你點擊的就是 a 標籤, 怎么知道点击的是一级还是二级还是三级
​ 问题：参数怎么携带，要携带携带哪些个的参数

## 29、利用自定义属性携带动态数据

标签的 data-开头的属性，叫做自定义属性
通过我们的标签对象.dataset

## 30、搜索页的 typeNav 一级列表隐藏

    1. typeNav這個組件在home當中一上來是顯示sort的, 在search當中一上來就要隱藏sort, sort
    	需要使用v-show, 在組件mounted的時候, 需要添加判斷是不是search, 如果是search頁面, 需要把isShow改為false
    2. 移入search頁面的全部商品分類, sort是要顯示的, 移出以後sort又是要隱藏的
    	移入的時候: 需要在原來自己添加的div身上, 再去添加移入事件, 讓isShow變為true
    	移出的時候: 原本自己添加的div身上我們已經寫過移出事件, 但邏輯需要添加,
    				修改為回調函數去做
    				移出的時候也得去判斷是不是在search移出, 如果是的需要隱藏sort

## 31、显示和隐藏一级列表的过渡效果添加

首先谁要加过渡就看谁在隐藏和显示
需要放在 transition 标签内部，name 需要起名字
参考官方给的过渡图
移入的时候是有过渡的
移出的时候立马隐藏的
注意：高度也是变化的

## 32、优化 typeNav 数据 ajax 请求次数，改变请求的位置

之前我们是在 typeNav 组件内部 dispatch 去发送 ajax 请求，这样的话
因为 typeNav 是被多个页面公用的，所以每次切换到一个页面，这个组件都会重新创建 mounted 都会执行
因此有几个页面公用了这个 typeNav 就会执行几次 ajax 请求还不包含切换
所以我们放到 App 里面就只用执行一次，因为数据一样，没必要多次请求

## 33、合并分类的 query 参数和搜索关键字的 params 参数

找到对应组件
点击 search 按钮的时候，去看看有没有 query 参数
点击类别选项的时候，去看看有没有 params 参数
注意：我们点击搜索的时候关键字使用的是 params 参数
点击类别选项的时候我们的参数使用的是 query 参数

到此为止我们的类别选项列表就完成了，后面开始做 ListContainer 和 Floor

### day04

接下来我们就要做首页的 ListContainer 和 Floor 组件

## 34、设计 json 数据的结构和值

banner.json
floor.json

## 35、使用 mockjs 来模拟数据接口（其实和 ajax 差不多，mock 其实就是给我们的 json 数据指定一个 url 路径去做请求）

1. 准备 json 数据
2. 安裝 npm i mockjs -S
3. 使用 mockjs 来模拟提供接口地址
4. 在 main 中引入 mockServer.js
5. 在 ajax 当中修改 Ajax 中的 baseUrl 为 /mock 变为一个新的文件 mockAjax

   mock 会拦截我们的 ajax 请求，不会真正去发送请求。（发送请求是往本地发的，没有往后端发，请求的数据也是本地的）

## 36、mock 数据的随机语法

看文档

## 37、動態展示 ListContainer 組件

    和 categoryList 的获取几乎一致，把 mock 接口当真正接口对待就好了

    1.寫api裡面的接口請求函數
    2.寫vuex(store)當中的三連環
    3.在組件當中dispatch發請求獲取數據存儲到vuex
    4.在組件當中computed內部, 從vuex當中把數據撈到組件
    5.在組件當中展示我們的動態數據

## 38、实现页面轮播

    swiper 的用法参考官方网站

    1.安装 npm i swiper@5 -S
    2.引入 js 和 css 可以查看頁面結構是否正常, 正常就代表CSS沒問題
    3.書寫swiper数据结构
    4.實例化swiper實例對象

    注意: swiper必須在頁面的數據結構顯示完成後創建才會生效

## 39、动态显示 Floor 组件

    数据要对应起来
    和上面展示bannerList一樣的道理
    主要是觀察獲取的動態數據去顯示

## 40、解决 swiper 影响多个页面的 bug

    通过选择器可以指定哪个地方需要，但是不好
    通过ref最好

## 41、swiper 创建的时间应该是在页面列表创建之后才会有效果

静态页面是没问题的
静态页面不需要等待数据，因此 monted 完全可以去创建 swiper

    现在我们的数据是动态的，monted内部去创建，数据还没更新到界面上，因此无效
    可以使用延迟定时器去创建 但是不好

## 42、使用 watch + nextTick 去解决比较好

Vue.nextTick 和 vm.\$nextTick 效果一样
nextTick 是在最近的一次更新 dom 之后会立即调用传入 nextTick 的回调函数

## 43、Floor 当中的轮播没效果？

它是根据数据循环创建组件对象的，外部的 floor 创建的时候
所以数据肯定是已经获取到了，所以我们在 mounted 内部去创建 swiper

## 44、定义可复用的轮播组件

banner 是在 watch 当中去创建 swiper 因为组件创建的时候数据不一定更新
floor 是在 mounted 当中去创建 swiper，因为内部组件创建的时候，数据已经存在了

## 45、查看数据的时候应该怎么去查看

看组件没有数据 接着看 vuex 没有数据 然后看 network 请求状态

//到此 首页逻辑就算告一段落 下面开始就是搜索页

### day05

## 46、实现 search 与 searchSelector 静态组件

searchSelector 是 search 组件的一个子组件

## 47、search 接口测试和编写请求函数 （参数按照文档的给定）

参考接口文档去做

## 48、search 模块 vuex 编码

编码和前面的类似 每写一步就测试一步

## 49、搜索条件参数注意

传递参数对象，至少得传递一个没有属性的对象

## 50、search 组件动态显示（先不搜索，获取数据去动态展示）

data 设置初始准备参数已经设置好了
在 mounted 内部可以发送请求
在 computed 内部获取我们的数据
search 页面商品动态数据展示
searchSelector 组件内部数据动态展示

```
	平台屬性的數據結構
	attrList:[
		{
			attrId:100,
			attrName:'螢幕大小',
			attrValueList:['5吋','8吋','10吋']
		},{},{}
	]
```

## 51、根据分类和关键字进行搜索，解决在 search 组件内部再进行搜索的 bug

1. data 當中的 searchParams 是我們需要定義的一個對象, 代表是所有的搜索條件
   組成的對象, 稱為初始化搜索的參數
   - 一部分是全是全串, 這些是以後我們搜索時候自己要給的
   - 一部分是給定的, 這些是我們默認給後台傳遞的搜索參數, 要改, 自己改
2. 真正到了搜索页面我们都要去解析拿到相关的参数 修改我们的搜索参数

   - beforeMount 去同步更新 data 数据
   - mounted 去异步发送请求

3. 在搜索页重新输入关键字或者点击类别不会再发送请求，因为 mounted 只会执行
   一次，需要监视路由变化

## 52、动态显示和删除选中的搜索条件发送请求

判断参数内部是否存在 categoryName 存在就显示
判断参数内部是否存在 keyword 存在就显示
点击事件，如果删除就把参数对应的数据清除，顺便发送新的请求

## 53、解决删除选中的搜索条件后路径不变的 bug

上面删除发送请求我们的请求路径还是不变
我们需要手动去 push 跳转到去除对应参数的新路由

## 54、解决删除关键字后，输入框没有更新输入的 bug

组件间通信，删除关键字后通知 header 组件，全局事件总线的使用

## 55、根据品牌搜索（设置和删除）

​ 给对应品牌添加点击事件
​ 点击的时候需要给父组件 search 传递品牌的参数 参数结构参考接口文档
​ 子向父通信

## 56、根据属性搜索（设置和删除）

​ 给对应的属性值添加点击事件
​ 点击的时候需要给父组件 search 传递属性值参数 参数结构参考接口文档
​ 使用组件间通信
​ 点击删除的时候从参数内部把对应的属性值参数删除，数组的方法

day06

57、解决在搜索页多次跳转后不能直接返回 home 的问题
查看之前书写的所有跳转路由
如果是搜索页往搜索页去跳转使用 replace
如果是 home 页往搜索页去跳转使用 push

58、getters 的用法简化 searchSelector 中数据的获取 mapGetters 使用

59、响应式对象数据属性的添加和删除

    对象当中的属性数据更改会导致页面更改，响应式数据

    添加：
    	错的：如果对象当中没有对应的属性数据： 直接添加一个属性，这个属性不是响应式的
    		因为vue只是在开始对对象当中的所有属性添加getter和setter，后期直接添加的没有

    	对的：我们需要使用Vue.set  this.$set方法  这样的添加属性就是响应式的   必须对响应式对象添加属性

    删除：
    	错的： 直接delete删除对象当中的属性，不会导致页面更改
    		因为响应式属性只是在检测属性值的改变而不是检测属性的删除

    	对的：我们需要使用Vue.delete this.$delete方法  除了删除，还添加了更新界面的操作

60、排序数据的分析 4 种情况
​ orderFlag:orderType
​

61、动态确定排序项和排序方式
哪个排序项选中并且有背景色（根据数据中的 orderFlag 决定 active 的类名）
哪个排序选项有图标 同上
图标是向上还是向下（根据数据中的 orderType 决定）

    点击切换排序包含排序项和排序方式
    	点击当前排序项         切换排序方式
    	点击不是当前排序项     切换排序项指定默认排序方式
    	点击排序项的时候传递自身的排序项标识数据  一个方法搞定

62、模板内部的表达式优化计算属性值

63、分页组件

64、自定义通用的分页组件

    1、去课件当中获取到分页的静态组件
    2、注册组件并渲染静态组件


    3、动态组件的逻辑和功能
    	3-1：思考设计 分页组件所需要的从父组件传递的数据是那些（1、当前页码  2、每页数量  3、总数  4、连续页数）
    	3-2：思考设计 分页内部需要计算的数据：总页数  连续页码的起始和结束
    	3-3：在分页当中开始去计算逻辑

    实现静态组件（模板结构样式）
    	参考文档去获取



    设计数据
    	外部接受的
    		当前页码
    		每页数量
    		总数
    		连续页码数量   一般都是奇数个

    	自己内部计算的
    		总页数
    		连续页码的起始和结束

    		1、先判断连续页码数是不是比最大的页码还要大，如果是那么start=1  end就是最大页码

    		2、如果连续页码数比最大页码小
    			我们让start  =   当前页码 - 连续页码/2 取整
    			      end   =    当前页码 + 连续页码/2 取整

    			     如果start 求出来比1还小  那么start修正为1 end需要+修正的偏移量    1 - start
    			     如果end   求出来比最大页码还大   同样end修正为最大页码   start - 修正的偏移量
    												end - totalpagenum


    	动态显示页码

    		每一个button都要考虑什么时候显示  还有什么时候是选中状态

    		什么时候显示和禁止操作
    			上一页：如果当前页等于1 禁止操作
    			第1页： 当start大于1才会显示
    			。。。: 当start大于2
    			中间的连续页： v-for遍历  然后判断 如果大于等于start才会显示
    			。。。: 当当前页小于总页数 - 1才会显示
    			最后一页：当end小于最后一页，才会显示
    			下一页：如果当前页等于最后一页 禁止操作

    		什么时候选中状态
    			如果当前页和目前遍历的这个页码是一样的，那么就添加active类

点击页码修改当前页码值
每个都要考虑 第一页 上一页 中间的连续页 最后一页 下一页

    	更新页码父组件要去发请求
    		把自身改变页码传给父组件修改参数重新发送请求


    	父组件搜索条件更新，需要当前页码修改为1
    		分页也就从1开始了，因为它是父的页码传递过去的

day07

65、详情组件
一个一级路由组件，使用已经写好的
商品列表页点击商品会跳转到详情页 需要携带 params 参数 商品 id
配置路由
跳转过去后可能滚动条位置不对（参考 router 官网滚动配置）
注意是给路由器配置的选项

66、浏览器发送 ajax 请求，携带属性值如果是 undefined 不会发送，但是如果是“”是要发送的
如何优化，在发送请求前把空串的属性干掉，但是不能影响原来的内部属性

67、Detail 组件动态显示
ajax 请求函数
vuex 管理
获取数据
展示数据
商品数据
放大镜大图和小图拿的是同一套 全部让父组件传递过去就好了（要处理假报错的问题）

    交互
    	图片列表的点击切换样式
    	图片列表点击大图要跟着切换  组件通信index下标

    	放大镜
    		鼠标动
    		遮罩动
    			求遮罩的位置
    			设置遮罩的位置
    		大图动
    			大图反向移动遮罩的位置2倍


    	商品售卖属性的点击切换（排它）

68、添加购物车需要发送请求，跳转到添加购物车成功

    如何知道成功还是失败
    	1、分发的时候传过去一个回调函数作为参数



    	2、使用promise
    		async和await


    		async函数返回值是一个promise   而且这个promise的状态结果  由当前函数return的返回值决定
    		promise状态返回：
    			函数返回undefined       成功
    			函数正常返回值          成功
    			函数返回 成功的promise  成功

    	函数返回 失败的promise  失败
    			函数抛出错误            失败

成功之后跳转路由到添加成功组件 需要带一个 query 参数 skuNum

添加成功组件需要用到商品信息所以跳转路由要保存商品信息 保存信息的多种方式（localStorage 和 sessionStorage）

动态显示添加成功页面数据

day08

69、购物车 shopCart 静态组件

    调整css让各个项目对齐    删除第三项   15  35  10 17 10 13

70、购物车组件动态展示
​ 请求数据
​ 展示：
​ 数据是要去请求接口的
​ 请求购物车列表数据
​ 写了接口请求发送也获取不到数据，因为没有身份标识
​ 用户的临时 id（userTempId）
​ 用户没有登录前的身份标识
​ 如果没有登录，用户需要查询数据，需要带上这个身份标识
​ 它是一个随机的唯一的字符串标识 uuid

    			创建和保存
    				浏览器端创建，每次请求都携带上，尽量不要修改
    				应用一打开就创建保存在localStorage
    				在state当中也去保存一份，这样的话为了更快

    			使用
    				使用请求拦截器每个请求都带上

    			做法：
    				书写工具函数去实现创建和保存uuid值
    				在state当中去调用这个函数
    				在ajax发送请求时候，所有请求头当中携带这个标识

    		展示购物车数据（需要计算）








    	交互：
    		更新购物车数量数据

    		更新购物车选中状态数据

Promise.all() 处理多个 promise 的数组，如果都成功那么返回的 promise 才成功，结果是每个成功的 promise 的结果组成的数组
如果失败，返回的第一个失败的 promise 的 reason

    		删除购物车数据

购物车完成后该去创建订单了，此时登录注册就必须要搞定，因为只有登录的用户才有创建订单的可能

day 09
71、 注册：
静态组件
api
store
收集数据发送请求
请求成功代表注册成功，那么就跳转到登录页
72、 登录：
静态组件
api
store
收集数据发送请求
请求成功后需要把用户信息保存在 localStorage 用于自动登录
state 的用户信息也要修改，
state 的用户信息读取先从 localStorage 里面去读，没有就是{},通过登录去修改
以后每次发请求都要携带这个用户信息的 token
修改头部的用户状态信息

    自动登录：  不需要请求 就是把用户信息存储完了再次打开取出展示

73、 退出登录：
​
请求成功在 store 中把用户信息的数据清除（state 和 localStorage 里面都要清除）

74、 携带 token 去进行后续操作

    userTempId和token的区别

    	userTempId  未登录状态下的用户身份识别标识

    	token       登录状态下的用户身份识别标识

    	两个都存在的话，后台会合并临时id对应的信息到token对应的信息上

登录注册完成再去做订单交易的流程

点击购物车结算会去到订单交易 trade 页面=》 这个页面在准备创建订单的信息

点击订单交易页面提交订单=》 真正的把创建订单的信息提交发送请求，真正的去创建订单，返回的是订单编号
也就是我们必须在交易页面提交订单的时候发送请求去创建订单获取订单编号
没有订单编号，直接跳转到支付页面没意义

会去到订单支付页面 =》 前面交易页面提交订单拿到了订单编号会跳过来
点击立即支付会弹出二维码

75、

    点击购物车结算会去到订单交易页面   去到之后需要发请求获取创建订单所需要的的交易信息，完成页面展示

    静态组件显示
    api
    store
    组件发请求
    获取数据
    组件展示数据
    完成交互

76、 点击创建订单页面提交订单 需要先发请求 提交订单信息 成功返回订单编号 把订单编号携带跳转路由去到订单支付页面

    在订单交易信息页面发送提交订单请求
    如果成功 路由跳转到支付页面，需要把提交订单成功的订单编号携带过去

77、 订单支付页面也需要支付信息 需要在订单支付页面根据订单编号发送请求获取支付信息，完成页面展示
需要发请求根据订单编号，查询订单数据，展示页面

78、 点击订单支付页面立即支付会出现一个支付二维码
订单数据当中包含了一个 codeUrl，是用来让我们生成二维码用的

    npm install --save qrcode   但是github去搜索的时候，搜索node-qrcode  用于把返回的图片地址生成二维码

    使用element-ui去做弹出显示  参考官网进行局部配置和打包






    支付流程：
    	1、生成了二维码
    	2、messageBox展示了二维码
    	3、刚展示完二维码：立马就需要发请求（这个请求要连续的去发） 隔2秒发一次 ，去查询支付状态是否支付完成
    	4、后台会在发请求后返回支付状态码  支付状态码如果是205代表还在支付中，如果是200代表支付成功
    	5、根据返回的支付状态码去决定后续操作
    			1》如果在查询回来是200的时候，我们要自动跳转到支付成功页面，关闭messageBox,
    			2》把这个状态码还要保存在data当中，用来去作为用户点击已成功支付按钮的判断依据

    	6、去单独的处理点击我已成功支付或者支付遇到问题按钮的逻辑
    			1》点击我已成功支付，那么要根据data当中存储的状态码判断是否真的支付完成，
    				如果完成跳转到支付成功页面，关闭messageBox,
    				如果没有完成，停在当前页面并提示,不关闭messageBox,

    			2》点击支付遇到问题，那么我们要提示用户找谁处理，停止往后台发请求，关闭messageBox





    点击立即支付
    	1、我们需要根据codeUrl 使用qrcode生成要显示的微信二维码url
    	2、使用element-ui的this.$alert 弹出消息框显示二维码图片，使用需要显示html的消息框
    	3、弹出消息框的时候，我们需要循环定时器去查询支付状态
    	4、如果支付成功，那么把支付成功的状态码保存在data当中，并且清除定时器，自动跳转到支付成功页面
    	5、如果点击我已经支付成功，那么需要判断状态码是不是成功，如果成功那就关闭提示框，不成功就提示不关闭
    		（需要放在messageBox的beforeClose回调当中去，判断 然后手动关闭）
    	6、如果点击支付失败，那么需要提示信息 清除定时器  关闭提示框 关闭也要去手动关闭
    		（需要放在messageBox的beforeClose回调当中去，判断 然后手动关闭）
    	7、支付成功才能到支付成功页面，那么我们都要去花钱，所以把支付功能简化，直接点击就能跳

79、支付成功后我们可以跳转到支付成功页面
​ 静态组件

80、在支付成功页面我们可以选择继续购物，去到首页 也可以查看订单，去到用户中心

81、用户中心组件及子路由组件
子路由组件拆分 我的订单和团购订单
请求数据 在我的订单组件里面存储数据就好
展示我的订单页面
分页器的使用 和前面一样 把该传递的参数要传递过去 子组件点击修改页面，要通知父组件修改

82、路由守卫的理解（参考官网去写代码）
有特定条件才能去到相应的页面的功能
拦截路由，查看是否满足条件，满足的放行，不满足的处理

83、必须登录后才能访问的多个界面使用全局守卫
（交易相关、支付相关、用户中心相关） 自动跳转前面想而没到的页面

84、只有没登录才能看到登录的界面 路由独享守卫和组件守卫

85、只有携带了 skuNum 和 sessionStorage 内部有 skuInfo 数据 才能看到添加购物车成功的界面

86、只有从购物车界面才能跳转到交易页面（创建订单）

87、只有从交易页面（创建订单）页面才能跳转到支付页面

88、只有从支付页面才能跳转到支付成功页面

89、图片懒加载
还没有加载得到目标图片时, 先显示 loading 图片
在<img>进入可视范围才加载请求目标图片
参考文档去写

90、路由懒加载

    调用import函数把一次性打包的所有路由组件分开去打包加载

    const Home = () => import('@/views/Home')


    打包会打包成一个单独的文件

    访问哪一个再去加载哪一个

    (1）	当打包构建应用时，JS包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，
    	然后当路由被访问的时候才加载对应组件，这样就更加高效了

    (2)	本质就是Vue 的异步组件在路由组件上的应用

    (3)	需要使用动态import语法, 也就是import()函数

    (4)	import('模块路径'): webpack会对被引入的模块单独打包一个小文件

    (5)     当第一次访问某个路径对应的组件时，此时才会调用import函数去加载对应的js打包文件

91、验证规则插件的使用 vee-validate 使用 2 版本 最新 3 版本

结算到支付的流程
1、购物车页面点击了结算直接跳转到订单交易页面

2、跳转到订单交易页面需要发请求获取订单交易信息
订单的交易信息 1、为了获取创建订单所用的交易编号
2、为了让用户去确定最终的交易信息

3、点击订单交易页面下边的提交订单
点击这个按钮不是立马就跳转到支付页面
先要根据交易信息和交易编号，发请求真正的去创建订单，返回订单编号之后再去跳转到支付页面，带上订单编号

```

```

```

```
